<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Why Malebranche?</title>
	<style>
		body {
			margin : 0;
			padding : 12px;
		}

		iframe {
			width : 100%;
			height : 600px;
			border : solid 1px #ddd;
		}

		#rect-2 {
			width : 200px;
			height : 300px;
			background : green;
		}

		#rect-3 {
			width : 200px;
			height : 100px;
			background : red;
			margin : 20px;
		}
		#rect-4 {
			width : 50px;
			height : 300px;
			background : cornflowerblue;
		}

		#rect-2, #rect-3, #rect-4 {
			display : inline-block;
			-webkit-clip-path : url(#svgPath2);
			margin : 20px;
		}

		blockquote {
			padding : 10px;
			color : blue;
			font-style : italic;
		}

		.container {
		}
		pre {
			font-family : courier;
		}
		img {
			-webkit-clip-path : url(#svgPath);
		}
	</style>
</head>
<body>
	<svg height="0" width="0">
		<defs>
			<clipPath id="svgPath">
				<path fill="#FFFFFF" stroke="#000000" stroke-width="1.5794" stroke-miterlimit="10" d="M100 0L200 200L 0 200Z"/>
			</clipPath>
		</defs>
	</svg>

	<svg height="0" width="0">
		<defs>
			<clipPath id="svgPath2" clipPathUnits="objectBoundingBox">
				<path fill="#FFFFFF" stroke="#000000" stroke-width="1.5794" stroke-miterlimit="10" d="M0.5 0L1 1L 0 1Z"/>
			</clipPath>
		</defs>
	</svg>
	<div id='rect-2'></div>
	<div id='rect-3'></div>
	<div id='rect-4'></div>


	<h1>Malebranche</h1>
	<p>The clip-path css property defines a clipping region for an element hiding parts of the element outside of
	the border of the region. The region can be defined using a shape function or by refererence to an SVG clip path.
		It is the latter method that we are concerned with here.</p>
	<p>According to the spec, the clippath can be either an inline SVG or an external SVG file; however external
	SVGs are not currently supported by most browsers.</p>
	<p>The basic concept is quite simple: an SVG clip path element defines a path which is referenced by an html element
	via the clip-path property. The path is used to form the clipping region. In practise however, clipping paths can be
	quite tricky to work with. Take the following example which was taken from Codepen. </p>
	<iframe src='clip-path-example.html'></iframe>

	<p>
		The problem, as you will find if you attempt to move the element in any way, is that neither the position of the clipping region
		or its size are related in any way to the element that we are trying to clip. This means that the effect will only work if our
		element is correctly sized according to the path and positioned. Worse still, the path is anchored to the top of the page! (this is why
		we have included the example within an iframe).
		 For anything other than experimental examples this is obviously not much use!</p>
	<p>
		The problem lies in the value of the clipPathUnits attribute of the clipPath element. If we do not explicitly specify it it's default value
		is "UserSpaceOnUse". The SVG spec says this about it:
		</q>
	</p>
	<blockquote cite="https://www.w3.org/TR/SVG/masking.html#ClipPathElement">
		If clipPathUnits="userSpaceOnUse", the contents of the ‘clipPath’ represent values in the current user coordinate
		system in place at the time when the ‘clipPath’ element is referenced (i.e., the user coordinate system for
		the element referencing the ‘clipPath’ element via the ‘clip-path’ property).
	</blockquote>
	<p>As we have seen, the user coordinate system is simply that of the browser viewport, hence why the clip path coords are unrelated to
	either the svg element which contains them, or the html element to which we attach them.</p>

	<p>
		I am still trying to find out what is meant by the 'user coordinate system'. if position is set to 'fixed' (in Chrome) the path will
		move with the element I have discovered. I need to devise a set of tests to establish this and do some more research.
	</p>
	<p>For most uses, what we actually want is a clipping region which adjusts to the size and position of our element. Happily it is
	possible to do this.</p>

	<p>The other possible value for clipPathUnits is "objectBoundingBox". The spec says this:</p>
	<blockquote cite="https://www.w3.org/TR/SVG/masking.html#ClipPathElement">
		If clipPathUnits="objectBoundingBox", then the user coordinate system for the contents of the ‘clipPath’ element is established using the bounding box of the element to which the clipping path is applied (see Object bounding box units).
		If attribute ‘clipPathUnits’ is not specified, then the effect is as if a value of 'userSpaceOnUse' were specified.
	</blockquote>


	<p>This is what we want. If we move or resize the element, the clipping region will adjust accordingly. But there is one caveat: the value of the coords must be fractional and within the range 0 and 1.
		I have created a <a href='http://jsfiddle.net/Richardinho/1196o7n0/4/'>JFiddle</a> which demonstrates this.
	</p>
	<p>
		One problem is that we will often find that the coords in our clipping path are not fractional. We can edit them ourselves but if
		it's a complicated path with bezier curves this quickly becomes unworkable. This is where Malebranche comes in. It's a node package
		which takes an svg file with absolute coordinates and converts them into fractional ones.
	</p>
<pre>
	malebranche src.svg destination.svg
</pre>




<p>
</body>
</html>